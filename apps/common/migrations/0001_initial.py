# Generated by Django (conceptual) and modified for pgvector index

from django.db import migrations, models
import pgvector.django # Required for VectorField and HnswIndex

class Migration(migrations.Migration):

    initial = True

    dependencies = [
        # pgvector extension should be enabled in PostgreSQL.
        # This can be done with a previous migration using:
        # from pgvector.django import VectorExtension
        # migrations.RunSQL("CREATE EXTENSION IF NOT EXISTS vector;")
        # or VectorExtension() operation if using a version that supports it.
        # For this example, we assume the extension is enabled.
        # If not, you'd add VectorExtension() here or in a 0000_... migration.
    ]

    operations = [
        # Ensure pgvector extension is enabled (idempotent)
        pgvector.django.VectorExtension(), # This operation creates the extension if it doesn't exist.

        migrations.CreateModel(
            name='VectorDocument',
            fields=[
                ('id', models.BigAutoField(primary_key=True, serialize=False)),
                ('text_content', models.TextField(help_text='The actual text content that was embedded.')),
                ('embedding', pgvector.django.VectorField(dimensions=1536, help_text='Vector embedding of the text_content.')),
                ('source_type', models.CharField(db_index=True, help_text="Type of the source document (e.g., 'job_listing', 'career_article', 'faq').", max_length=50)),
                ('source_id', models.CharField(blank=True, db_index=True, help_text='Identifier of the original source object (e.g., Job ID, Article ID).', max_length=255, null=True)),
                ('metadata', models.JSONField(blank=True, default=dict, help_text='Additional metadata for filtering or display (e.g., company, location, category, tags).')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'Vector Document',
                'verbose_name_plural': 'Vector Documents',
                'unique_together': {('source_type', 'source_id')},
            },
        ),
        # Add HNSW index for the embedding field for efficient similarity search.
        # This is a common practice for pgvector.
        # The opclasses should match the distance function you intend to use primarily.
        # 'vector_l2_ops' for L2 distance (Euclidean)
        # 'vector_cosine_ops' for cosine distance (1 - cosine similarity)
        # 'vector_ip_ops' for inner product (negative inner product for distance)
        # OpenAI embeddings are normalized, so L2 distance and cosine similarity are related.
        # L2 distance is often a good default.
        migrations.AddIndex(
            model_name='VectorDocument',
            index=pgvector.django.HnswIndex(
                name='vectordoc_embedding_hnsw_l2_idx',
                fields=['embedding'],       # Corrected from field_name
                m=16,
                ef_construction=64,
                opclasses=['vector_l2_ops']
            ),
        ),
        # Alternatively, for IVFFlat index (another common type):
        # migrations.AddIndex(
        #     model_name='VectorDocument',
        #     index=pgvector.django.IvfflatIndex(
        #         name='vectordoc_embedding_ivfflat_l2_idx',
        #         fields=['embedding'],
        #         lists=100,
        #         opclasses=['vector_l2_ops']
        #     )
        # ),
        # pgvector.django.IvfflatIndex(
        #     name='vectordoc_embedding_ivfflat_l2_idx',
        #     model_name='VectorDocument',
        #     field_name='embedding',
        #     lists=100, # Example: 10% of expected rows, or sqrt(N)
        #     opclasses=['vector_l2_ops']
        # ),
    ]
